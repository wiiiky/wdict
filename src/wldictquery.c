/*
 * Copyright (C) 2014-2014 Wiky L(wiiiky@yeah.net)
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * this file is generated by gobj(https://github.com/wiiiky/gobj)
 */

#include "wldictquery.h"
#include <stdlib.h>

/* 百度开发平台申请的appid */
#define CLIENT_ID	"WOkykfPXheIbcGE2UvqRSU1f"

#define TARGET_URL	"http://openapi.baidu.com/public/2.0/bmt/translate?"\
	"from=%s&to=%s&client_id=" CLIENT_ID "&q=%s"

enum {
	PROP_FROM = 1,
	PROP_TO,
};

G_DEFINE_TYPE(WlDictQuery, wl_dict_query, G_TYPE_OBJECT);

static void wl_dict_query_init(WlDictQuery * obj);
static void wl_dict_query_finalize(GObject * obj);
static void wl_dict_query_class_init(WlDictQueryClass * klass);
static void wl_dict_query_getter(GObject * object, guint property_id,
								 GValue * value, GParamSpec * ps);
static void wl_dict_query_setter(GObject * object, guint property_id,
								 const GValue * value, GParamSpec * ps);

static void wl_dict_query_init(WlDictQuery * query)
{
	query->cancel = NULL;
}

static void wl_dict_query_finalize(GObject * obj)
{
}

static void wl_dict_query_class_init(WlDictQueryClass * klass)
{
	GObjectClass *obj_class = G_OBJECT_CLASS(klass);
	obj_class->get_property = wl_dict_query_getter;
	obj_class->set_property = wl_dict_query_setter;
	obj_class->finalize = wl_dict_query_finalize;

	GParamSpec *ps;
	/* properties */
	ps = g_param_spec_enum("from",
						   "from language",
						   "From Language",
						   WL_TYPE_DICT_LANG,
						   WL_DICT_AUTO,
						   G_PARAM_READABLE | G_PARAM_WRITABLE |
						   G_PARAM_CONSTRUCT);
	g_object_class_install_property(obj_class, PROP_FROM, ps);

	ps = g_param_spec_enum("to",
						   "to language",
						   "To Language",
						   WL_TYPE_DICT_LANG,
						   WL_DICT_AUTO,
						   G_PARAM_READABLE | G_PARAM_WRITABLE |
						   G_PARAM_CONSTRUCT);
	g_object_class_install_property(obj_class, PROP_TO, ps);
}

static void wl_dict_query_getter(GObject * object, guint property_id,
								 GValue * value, GParamSpec * ps)
{
	WlDictQuery *obj = WL_DICT_QUERY(object);
	switch (property_id) {
	case PROP_FROM:
		g_value_set_enum(value, obj->from);
		break;
	case PROP_TO:
		g_value_set_enum(value, obj->to);
		break;
	default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, ps);
	}
}

static void wl_dict_query_setter(GObject * object, guint property_id,
								 const GValue * value, GParamSpec * ps)
{
	WlDictQuery *obj = WL_DICT_QUERY(object);
	switch (property_id) {
	case PROP_FROM:
		obj->from = g_value_get_enum(value);
		break;
	case PROP_TO:
		obj->to = g_value_get_enum(value);
		break;
	default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, ps);
	}
}

GType wl_dict_lang_get_type(void)
{
	static GType etype = 0;
	if (G_UNLIKELY(etype == 0)) {
		static const GEnumValue values[] = {
			{WL_DICT_ZH, "WL_DICT_ZH", "zh"},
			{WL_DICT_EN, "WL_DICT_EN", "en"},
			{WL_DICT_JP, "WL_DICT_JP", "jp"},
			{WL_DICT_KOR, "WL_DICT_KOR", "kor"},
			{WL_DICT_SPA, "WL_DICT_SPA", "spa"},
			{WL_DICT_FRA, "WL_DICT_FRA", "fra"},
			{WL_DICT_TH, "WL_DICT_TH", "th"},
			{WL_DICT_ARA, "WL_DICT_ARA", "ara"},
			{WL_DICT_RU, "WL_DICT_RU", "ru"},
			{WL_DICT_PT, "WL_DICT_PT", "pt"},
			{WL_DICT_YUE, "WL_DICT_YUE", "yue"},
			{WL_DICT_WYW, "WL_DICT_WYW", "wyw"},
			{WL_DICT_AUTO, "WL_DICT_AUTO", "auto"},
			{0, NULL, NULL}
		};
		etype =
			g_enum_register_static(g_intern_static_string("WlDictLang"),
								   values);
	}
	return etype;
}

typedef struct {
	gchar *src;					/* 待查询的原字符串 */
	WlDictLang from, to;
	WlDictQueryCallback cb;
	gpointer cbData;
} TaskData;

static void onTaskDataDestroy(gpointer data)
{
	TaskData *td = data;
	g_free(td->src);

	g_free(td);
}

static inline void cancelQuery(WlDictQuery * query)
{
	if (query->cancel) {
		g_cancellable_cancel(query->cancel);
		g_object_unref(query->cancel);
	}
	query->cancel = NULL;
}

static inline void newQueryCancellable(WlDictQuery * query)
{
	cancelQuery(query);
	query->cancel = g_cancellable_new();
}

static void onTaskReadyCallback(GObject * source, GAsyncResult * res,
								gpointer userData)
{
	GError *err = NULL;
	//WlDictQuery *query=WL_DICT_QUERY(source);
	TaskData *td = g_task_get_task_data(G_TASK(res));
	gchar *responseBody = g_task_propagate_pointer(G_TASK(res), &err);
	if (err) {					/* Error */
		if (td->cb)
			td->cb(td->from, td->to, td->src, NULL, td->cbData, err);
		return;
	}

	JsonParser *parser = json_parser_new();
	if (!json_parser_load_from_data(parser, responseBody, -1, &err)) {
		if (td->cb)
			td->cb(td->from, td->to, td->src, NULL, td->cbData, err);
		g_message("%s", responseBody);
		return;
	}
	JsonNode *rootNode = json_parser_get_root(parser);
	JsonObject *rootObj = json_node_get_object(rootNode);
	const gchar *from = json_object_get_string_member(rootObj, "from");
	const gchar *to = json_object_get_string_member(rootObj, "to");

	if (json_object_has_member(rootObj, "error_code")) {
		/* 查询出错 */
		const gchar *error_msg =
			json_object_get_string_member(rootObj, "error_msg");
		const gchar *error_code =
			json_object_get_string_member(rootObj, "error_code");
		if (td->cb) {
			GError *error =
				g_error_new(G_IO_ERROR, atoi(error_code), "%s", error_msg);
			td->cb(wl_dict_lang_get_enum(from), wl_dict_lang_get_enum(to),
				   json_object_get_string_member(rootObj, "query"), NULL,
				   td->cbData, error);
			g_error_free(error);
		}
		g_object_unref(parser);
		return;
	}

	JsonArray *results =
		json_object_get_array_member(rootObj, "trans_result");
	gint i, len = json_array_get_length(results);
	for (i = 0; i < len; i++) {
		JsonObject *resEle = json_array_get_object_element(results, i);
		const gchar *src = json_object_get_string_member(resEle, "src");
		const gchar *dst = json_object_get_string_member(resEle, "dst");
		if (td->cb)
			td->cb(wl_dict_lang_get_enum(from),
				   wl_dict_lang_get_enum(to), src, dst, td->cbData, NULL);
	}
	g_object_unref(parser);
}

static void taskThread(GTask * task, gpointer source,
					   gpointer taskData, GCancellable * cancellable)
{
	TaskData *td = taskData;
	gchar *q = g_uri_escape_string(td->src, NULL, TRUE);
	gchar *target = g_strdup_printf(TARGET_URL,
									wl_dict_lang_get_phrase(td->from),
									wl_dict_lang_get_phrase(td->to), q);
	g_free(q);
	SoupMessage *msg = soup_message_new("GET", target);

	if (msg == NULL) {
		GError *error = g_error_new(G_IO_ERROR, 2,
									"failed to parse URL %s", target);
		g_free(target);
		g_task_return_error(task, error);
		return;
	}
	g_free(target);

	static SoupSession *session = NULL;
	if (session == NULL) {
		session = soup_session_new();
	}

	if (g_task_return_error_if_cancelled(task)) {
		g_object_unref(msg);
		return;
	}

	guint status = soup_session_send_message(session, msg);
	if (!SOUP_STATUS_IS_SUCCESSFUL(status)) {
		g_object_unref(msg);
		g_task_return_new_error(task, G_IO_ERROR, status,
								"%s", soup_status_get_phrase(status));
		return;
	}

	if (g_task_return_error_if_cancelled(task)) {
		g_object_unref(msg);
		return;
	}

	SoupMessageBody *body = NULL;
	g_object_get(msg, "response-body", &body, NULL);
	gchar *responseBody = g_strdup(body->data);
	g_object_unref(msg);
	g_task_return_pointer(task, responseBody, g_free);
}

/**************************************************
 * PUBILC
 **************************************************/
WlDictQuery *wl_dict_query_new(WlDictLang from, WlDictLang to)
{
	g_return_val_if_fail(WL_IS_DICT_LANG(from)
						 && WL_IS_DICT_LANG(to), NULL);
	WlDictQuery *query = WL_DICT_QUERY(g_object_new(WL_TYPE_DICT_QUERY,
													"from", from, "to", to,
													NULL));

	return query;
}

void wl_dict_query_query(WlDictQuery * query, const gchar * src,
						 WlDictQueryCallback cb, gpointer userData)
{
	g_return_if_fail(WL_IS_DICT_QUERY(query) && src != NULL);

	TaskData *td = g_malloc(sizeof(TaskData));
	td->src = g_strdup(src);
	td->from = query->from;
	td->to = query->to;
	td->cb = cb;
	td->cbData = userData;

	newQueryCancellable(query);
	GTask *task =
		g_task_new(query, query->cancel, onTaskReadyCallback, NULL);
	g_task_set_task_data(task, td, onTaskDataDestroy);
	g_task_run_in_thread(task, taskThread);
	g_object_unref(task);
}

void wl_dict_query_set_from(WlDictQuery * query, WlDictLang from)
{
	g_return_if_fail(WL_IS_DICT_QUERY(query) && WL_IS_DICT_LANG(from));
	g_object_set(query, "from", from, NULL);
}

void wl_dict_query_set_to(WlDictQuery * query, WlDictLang to)
{
	g_return_if_fail(WL_IS_DICT_QUERY(query) && WL_IS_DICT_LANG(to));
	g_object_set(query, "to", to, NULL);
}

WlDictLang wl_dict_query_get_from(WlDictQuery * query)
{
	g_return_val_if_fail(WL_IS_DICT_QUERY(query), 0);
	return query->from;
}

WlDictLang wl_dict_query_get_to(WlDictQuery * query)
{
	g_return_val_if_fail(WL_IS_DICT_QUERY(query), 0);
	return query->to;
}

const gchar *wl_dict_lang_get_phrase(WlDictLang lang)
{
	g_return_val_if_fail(WL_IS_DICT_LANG(lang), NULL);
	switch (lang) {
	case WL_DICT_ZH:
		return "zh";
		break;
	case WL_DICT_EN:
		return "en";
		break;
	case WL_DICT_JP:
		return "jp";
		break;
	case WL_DICT_KOR:
		return "kor";
		break;
	case WL_DICT_SPA:
		return "spa";
		break;
	case WL_DICT_FRA:
		return "fra";
		break;
	case WL_DICT_TH:
		return "th";
		break;
	case WL_DICT_ARA:
		return "ara";
		break;
	case WL_DICT_RU:
		return "ru";
		break;
	case WL_DICT_PT:
		return "pt";
		break;
	case WL_DICT_YUE:
		return "yue";
		break;
	case WL_DICT_WYW:
		return "wyw";
		break;
	case WL_DICT_AUTO:
		return "auto";
		break;
	default:
		return NULL;
		break;
	}
	return NULL;
}

WlDictLang wl_dict_lang_get_enum(const gchar * lang)
{
	g_return_val_if_fail(lang != NULL, 0);
	if (g_strcmp0(lang, "zh") == 0)
		return WL_DICT_ZH;
	else if (g_strcmp0(lang, "en") == 0)
		return WL_DICT_EN;
	else if (g_strcmp0(lang, "jp") == 0)
		return WL_DICT_JP;
	else if (g_strcmp0(lang, "kor") == 0)
		return WL_DICT_KOR;
	else if (g_strcmp0(lang, "spa") == 0)
		return WL_DICT_SPA;
	else if (g_strcmp0(lang, "fra") == 0)
		return WL_DICT_FRA;
	else if (g_strcmp0(lang, "th") == 0)
		return WL_DICT_TH;
	else if (g_strcmp0(lang, "ara") == 0)
		return WL_DICT_ARA;
	else if (g_strcmp0(lang, "ru") == 0)
		return WL_DICT_RU;
	else if (g_strcmp0(lang, "pt") == 0)
		return WL_DICT_PT;
	else if (g_strcmp0(lang, "yue") == 0)
		return WL_DICT_YUE;
	else if (g_strcmp0(lang, "wyw") == 0)
		return WL_DICT_WYW;
	else if (g_strcmp0(lang, "auto") == 0)
		return WL_DICT_AUTO;
	return 0;
}
